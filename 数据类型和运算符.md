# 数据类型和运算符

## 一、数据类型 

### 1.1、变量和常量数据

#### 常量

是指程序在运行时其值不能改变的量。常量不占内存,在程序运行时它作为操作对象直接出现在运算器的各种寄存器中。

#### 变量

是指在程序运行时其值可以改变的量。变量的功能就是存储数据。

#### 变量的定义

在程序中使用的变量名、函数名、标号等统称为标识符。除库函数的函数名由系统定义外，其余都由用户自定义。

C规定，标识符只能是字母(A～Z，a～z)、数字(0～9)、下划线(_)组成的字符串，并且其第一个字符必须是***字母或下划线***。且不能与C语言的关键字重名。

在标识符中，大小写是有区别的。例如CLANG和Clang 是两个不同的标识符。

#### 实例

~~~c
#include<stdio.h>
int main()
{
    int year；
    year=2022；
    printf("Welcome to 2022\n");
    return 0；
}
~~~

现实生活中我们会找一个小箱子来存放物品，一来显得不那么凌乱，二来方便以后找到。计算机也是这个道理，我们需要先在内存中找一块区域，规定用它来存放整数，并起一个好记的名字，方便以后查找。这块区域就是“小箱子”，我们可以把整数放进去了。

C 语言中这样在内存中找一块区域：

```c
int  year;
```

`int`，它是 Integer 的简写，意思是整数。`year`是我们给这块区域起的名字；当然也可以叫其他名字，例如 `abc`、`mn123` 等。

这个语句的意思是：在内存中找一块区域，命名为 year，用它来存放整数。

```
注意 int 和 year 之间是有空格的，它们是两个词。也注意最后的分号，int  year表达了完整的意思，是一个语句，要用分号来结束。
```

不过 `int year;`仅仅是在内存中找了一块可以保存整数的区域，那么如何将 2008、2018、2022 这样的数字放进去呢？



C 语言中这样向内存中放整数：

```C
year=123;
```

`=`是一个符号，例如 1+2=3，但在 C 语言中，这个过程叫做**赋值（Assign）**。

**`赋值是指把数据放到内存的过程。`**

把上面的两个语句连起来：

```c
int year;
year=2022;
```

就把2022放到了一块叫做 `year`的内存区域。你也可以写成一个语句：

```c
int year=2022;
```



`year`中的整数不是一成不变的，只要我们需要，随时可以更改。更改的方式就是再次赋值，例如：

```c
int year=2022;
year=2023;
year=2024;
```

第二次赋值，会把第一次的数据覆盖（擦除）掉，也就是说，year中最后的值是2024，而2023、2022已经不存在了，再
也找不回来了。
因为 year 的值可以改变，所以我们给它起了一个形象的名字，叫做**变量（Variable）**。



*`int  year;`创造了一个变量 year，我们把这个过程叫做**变量定义**。*

*`year=2022;`把 2022交给了变量 year，我们把这个过程叫做给**变量赋值**；又因为是第一次赋值，也称**变量的初始化**，或者**赋初值**。*

你可以先定义变量，再初始化，例如：

```c
int abc;
abc=999;
```

也可以在定义的同时进行初始化，例如：

```c
int abc=999;
```

这两种方式是等价的。

在程序的世界中，承载一系列的信息的数字和字符都属于数据类型，但计算机需要一种方法来区别和使用这些不同的类型。具体的，C通过识别一些基本的数据类型做到这些。如果是常量数据，编译器一般通过其书写来辨认其类型，比如：123是整数，3.14浮点数(即小数)。而变量则需要在声明语句中指定其类型。

内存中的数据有多种解释方式，使用之前必须要确定；上面的 `int year;`就表明，这份数据是整数，不能理解为小数、字符等。int 有一个专业的称呼，叫做**数据类型（Data Type）**。
顾名思义，数据类型用来说明数据的类型，确定了数据的解释方式，让计算机和程序员不会产生歧义。

### 1.2基本数据类型

在程序的世界中，承载一系列的信息的数字和字符都属于数据类型，但计算机需要一种方法来区别和使用这些不同的类型。具体的，C通过识别一些基本的数据类型做到这些。如果是常量数据，编译器一般通过其书写来辨认其类型，比如：123是整数，3.14浮点数(即小数)。而变量则需要在声明语句中指定其类型。

内存中的数据有多种解释方式，使用之前必须要确定；上面的 `int year;`就表明，这份数据是整数，不能理解为小数、字符等。int 有一个专业的称呼，叫做**数据类型（Data Type）**。
顾名思义，数据类型用来说明数据的类型，确定了数据的解释方式，让计算机和程序员不会产生歧义。

#### 基本数据类型

C语言的基本数据类型为：整型、字符型、实数型。这些类型按其在计算机中的存储方式可被分为两个系列，即**整数(integer)类型**和**浮点数(floating-point)类型**。 
这三种类型之下分别是：short、int、long、char、float、double这六个关键字再加上两个符号说明符signed和unsigned就基本表示了C语言的最常用的数据类型。

| 说明         | 字符型 | 短整型 | 整形 | 长整型 | 单精度浮点型 | 双精度浮点型 |
| :----------- | :----: | :----: | :--: | :----: | :----------: | :----------: |
| **数据类型** |  char  | short  | int  |  long  |    float     |    double    |
| **长度**     |   1    |   2    |  4   |   4    |      4       |      8       |

#### 在屏幕上输出各种类型的数据

`printf` 是 print format 的缩写，意思是“格式化打印”。这里所谓的“打印”就是在屏幕上显示内容，与“输出”的含义相同，所以我们一般称 printf 是用来格式化输出的。
先来看一个简单的例子：

```c
printf("Hello，world！");
```

这个语句可以在屏幕上显示“Hello，world！”。



输出变量 abc 的值：

```c
int abc=999;
printf("%d", abc);
```

这里就比较有趣了。先来看%d，d 是 decimal 的缩写，意思是十进制数，%d 表示以十进制整数的形式输出。

输出什么呢？输出变量 abc 的值。%d 与 abc 是对应的，也就是说，会用 abc 的值来替换 %d。
再来看个复杂点的：

```c
int abc=999;
printf("The value of abc is %d !", abc);
```

会在屏幕上显示：`The value of abc is 999 !`
你看，字符串 "The value of abc is %d !" 中的 %d 被替换成了 abc 的值，其他字符没有改变。这说明 %d 比较特殊，不会原样输出，会被替换成对应的变量的值。



再来看：

```c
int a=100;
int b=200;
int c=300;
printf("a=%d, b=%d, c=%d", a, b, c);
```

会在屏幕上显示：`a=100, b=200, c=300`
再次证明了 %d 与后面的变量是一一对应的，第一个 %d 对应第一个变量，第二个 %d 对应第二个变量……



`%d` 称为**格式控制符**，它指明了以何种形式输出数据。格式控制符均以%开头，后跟其他字符。%d 表示以十进制形式输出一个整数。

除了 %d，printf 支持更多的格式控制，例如：

| 格式字符 |                                                    |
| :------: | -------------------------------------------------- |
|  %d , i  | 以十进制形式输出有符号整数(正数不输出符号)         |
|    %O    | 以八进制形式输出无符号整数(不输出前缀0)            |
|    %x    | 以十六进制形式输出无符号整数(不输出前缀0x)         |
|    %U    | 以十进制形式输出无符号整数                         |
|    %f    | 以小数形式输出单、双精度类型实数                   |
|    %e    | 以指数形式输出单、双精度实数                       |
|    %g    | 以%f或%e中较短输出宽度的一种格式输出单、双精度实数 |
|    %c    | 输出单个字符                                       |
|    %s    | 输出字符串                                         |



我们把代码补充完整，体验一下：

~~~c
#include <stdio.h>
int main()
{
int n = 100;
char c = '@'; //字符用单引号包围，字符串用双引号包围
float money = 93.96;
printf("n=%d, c=%c, money=%f\n", n, c, money);
return 0;
}
~~~

输出结果：

```
n=100, c=@, money=93.96
```

我们也可以不用变量，将数据直接输出：

~~~c
#include <stdio.h>
int main()
{
float money = 93.96;
printf("n=%d, c=%c, money=%f\n", 100, '@', money);
return 0;
}
~~~

输出结果与上面相同。 

### 1.3整数类型（short，int，long）

在现代操作系统中，`int` 一般占用 4 个字节（Byte）的内存，共计 32 位（Bit）。

让整数占用更少的内存可以在 `int` 前边加 `short`，让整数占用更多的内存可以在 `int` 前边加 `long`，例如：

~~~c
short int a = 10;
short int b = 99;
long int m = 102023;
long int n = 562131;
~~~

也可以将 int 省略，只写 short 和 long，如下所示：

~~~c
short a = 10;
short b = 99;
long m = 102023;
long n = 562131;
~~~

这样的写法更加简洁，实际开发中常用。

`int` 是基本的整数类型，`short` 和 `long` 是在 `int` 的基础上进行的扩展，`short` 可以节省内存，`long` 可以容纳更大的
值。
`short、int、long` 是 C 语言中常见的整数类型，其中 `int` 称为整型，`short` 称为短整型，`long` 称为长整型。

#### 整型的长度

C 语言并没有严格规定 `short、int、long` 的长度，只做了宽泛的限制：
`short` 至少占用 2 个字节。
`int` 建议为一个机器字长。32 位环境下机器字长为 4 字节，64 位环境下机器字长为 8 字节。
`short` 的长度不能大于 `int`，`long` 的长度不能小于 `int`。

总结起来，它们的长度（所占字节数）关系为：
`2 ≤ short ≤ int ≤ long`
这就意味着，`short` 并不一定真的”短“，long `也并不一定真的`”长“，它们有可能和 `int` 占用相同的字节数。

#### sizeof 操作符

获取某个数据类型的长度可以使用 sizeof 操作符，如下所示：

~~~c
#include <stdio.h>
int main()
{
short a = 10;
int b = 100;
int short_length = sizeof a;
int int_length = sizeof(b);
int long_length = sizeof(long);
int char_length = sizeof(char);
printf("short=%d, int=%d, long=%d, char=%d\n", short_length, int_length, long_length, char_length);
return 0;
}
~~~

在 32 位环境以及 Win64 环境下的运行结果为：
`short=2, int=4, long=4, char=1`
在 64 位 Linux 和 Mac OS 下的运行结果为：

`short=2, int=4, long=8, char=1`

sizeof 用来获取某个数据类型或变量所占用的字节数，如果后面跟的是变量名称，那么可以省略( )，如果跟的是数
据类型，就必须带上( )。

#### 不同整型的输出
使用不同的格式控制符可以输出不同类型的整数，它们分别是：
`%hd` 用来输出 short int 类型，hd 是 short decimal 的简写；
`%d` 用来输出 int 类型，d 是 decimal 的简写；
`%ld` 用来输出 long int 类型，ld 是 long decimal 的简写。

下面的例子演示了不同整型的输出：

~~~c
#include <stdio.h>
int main()
{
short a = 10;
int b = 100;
long c = 9437;
printf("a=%hd, b=%d, c=%ld\n", a, b, c);

return 0;
 }
~~~

运行结果：`a=10, b=100, c=9437`

在编写代码的过程中，我建议将格式控制符和数据类型严格对应起来，养成良好的编程习惯。

当使用%hd 输出 int、long，或者使用%d 输出 long 时，如果要输出的值比较小，一般也不会发生错误，如果要输出的值比较大，就很有可能发生错误，例如：

~~~c
#include <stdio.h>
int main()
{
int m = 306587;
long n = 28166459852;
printf("m=%hd, n=%hd\n", m, n);
printf("n=%d\n", n);
return 0;
 }
~~~

运行结果为：

```
`m=-21093, n=4556`
`n=-1898311220`
```

输出结果完全是错误的，这是因为%hd 容纳不下 m 和 n 的值，%d 也容纳不下 n 的值。

### 1.4C 语言中的二进制数、八进制数和十六进制数

#### 二进制数、八进制数和十六进制数的表示

1) **二进制**
二进制由 0 和 1 两个数字组成，使用时必须以 0b 或 0B（不区分大小写）开头，例如：

~~~C
//合法的二进制
int a = 0b101; //换算成十进制为 5
int b = -0b110010; //换算成十进制为 -50
int c = 0B100001; //换算成十进制为 33

//非法的二进制
int m = 101010; //无前缀 0B，相当于十进
int n = 0B410; //4不是有效的二进制数字
~~~

并不是所有的编译器都支持二进制数字，只有一部分编译器支持，并且跟编译器的版本有关系。*Visual Studio 2010 不支持*

2) **八进制**
八进制由 0~7 八个数字组成，使用时必须以 0 开头（注意是数字 0，不是字母 o），例如：

~~~c
//合法的八进制数
int a = 015; //换算成十进制为 13
int b = -0101; //换算成十进制为 -65
int c = 0177777; //换算成十进制为 65535

//非法的八进制
int m = 256; //无前缀 0，相当于十进制
int n = 03A2; //A不是有效的八进制数字
~~~

3. **十六进制**

  十六进制由数字 0~9、字母 A~F 或 a~f（不区分大小写）组成，使用时必须以 0x 或 0X（不区分大小写）开头，例如：

~~~C
//合法的十六进制
int a = 0X2A; //换算成十进制为 42
int b = -0XA0; //换算成十进制为 -160
int c = 0xffff; //换算成十进制为 65535

//非法的十六进制
int m = 5A; //没有前缀 0X，是一个无效数字
int n = 0X3H; //H不是有效的十六进制数字
~~~

4) **十进制**
十进制由 0~9 十个数字组成，没有任何前缀，和我们平时的书写格式一样，不再赘述。

#### 二进制数、八进制数和十六进制数的输出

C 语言中常用的整数有 short、int 和 long 三种类型，通过 printf 函数，可以将它们以八进制、十进制和十六进制的形式输出。

|          |  short   |  int   |   long   |
| :------: | :------: | :----: | :------: |
|  八进制  |   %ho    |  %hd   |   %lo    |
|  十进制  |   %hd    |   %d   |   %ld    |
| 十六进制 | %hx或%hX | %x或%X | %lx或%lX |

十六进制数字的表示用到了英文字母，有大小写之分，要在格式控制符中体现出来：
%hx、%x 和 %lx 中的 x 小写，表明以小写字母的形式输出十六进制数；
%hX、%X 和 %lX 中的 X 大写，表明以大写字母的形式输出十六进制数。

#### 【实例】以不同进制的形式输出整数：

~~~c
#include <stdio.h>
int main()
{
short a = 0b1010110; //二进制数字
int b = 02713; //八进制数字
long c = 0X1DAB83; //十六进制数字
printf("a=%ho, b=%o, c=%lo\n", a, b, c); //以八进制形似输出
printf("a=%hd, b=%d, c=%ld\n", a, b, c); //以十进制形式输出
printf("a=%hx, b=%x, c=%lx\n", a, b, c); //以十六进制形式输出（字母小写）
printf("a=%hX, b=%X, c=%lX\n", a, b, c); //以十六进制形式输出（字母大写）
return 0;
}
~~~

运行结果：

```
a=126, b=2713, c=7325603
a=86, b=1483, c=1944451
a=56, b=5cb, c=1dab83
a=56, b=5CB, c=1DAB83
```



#### 输出时加上前缀
注意观察上面的例子，会发现有一点不完美，如果只看输出结果：

- 对于八进制数字，它没法和十进制、十六进制区分，因为八进制、十进制和十六进制都包含 0~7 这几个数字。
- 对于十进制数字，它没法和十六进制区分，因为十六进制也包含 0~9 这几个数字。如果十进制数字中还不包含 8 和 9，那么也不能和八进制区分了。

- 对于十六进制数字，如果没有包含 a~f 或者 A~F，那么就无法和十进制区分，如果还不包含 8 和 9，那么也不能和八进制区分了。

区分不同进制数字的一个简单办法就是，在输出时带上特定的前缀。在格式控制符中加上#即可输出前缀，例如 %#x、%#o、%#lX、%#ho 等，请看下面的代码：

~~~C
#include <stdio.h>
int main()
{
short a = 0b1010110; //二进制数字
int b = 02713; //八进制数字
long c = 0X1DAB83; //十六进制数字
printf("a=%#ho, b=%#o, c=%#lo\n", a, b, c); //以八进制形似输出
printf("a=%hd, b=%d, c=%ld\n", a, b, c); //以十进制形式输出
printf("a=%#hx, b=%#x, c=%#lx\n", a, b, c); //以十六进制形式输出（字母小写）
printf("a=%#hX, b=%#X, c=%#lX\n", a, b, c); //以十六进制形式输出（字母大写）
return 0;
}
~~~

运行结果：

```
a=0126, b=02713, c=07325603
a=86, b=1483, c=1944451
a=0x56, b=0x5cb, c=0x1dab83
a=0X56, b=0X5CB, c=0X1DAB83
```

### 1.5 C 语言中的正负数及其输出

在数学中，数字有正负之分。在 C 语言中也是一样，short、int、long 都可以带上正负号，例如：

~~~c
//负数
short a1 = -10;
short a2 = -0x2dc9; //十六进制
//正数
int b1 = +10;
int b2 = +0174; //八进制
int b3 = 22910;
//负数和正数相加
long c = (-9) + (+12);
~~~

如果不带正负号，默认就是正数。

符号也是数字的一部分，也要在内存中体现出来。符号只有正负两种情况，用 1 位（Bit）就足以表示；C 语言规定，把内存的最高位作为符号位。以 int 为例，它占用 32 位的内存，0~30 位表示数值，31 位表示正负号。如下图所示：

![image-20230318145551126](C:\Users\王凯威\AppData\Roaming\Typora\typora-user-images\image-20230318145551126.png)

```
在编程语言中，计数往往是从 0 开始，例如字符串 "abc123"，我们称第 0 个字符是 a，第 1 个字符是 b，第 5``个字符是 3。这和我们平时从 1 开始计数的习惯不一样，大家要慢慢适应，培养编程思维。
```

C 语言规定，在符号位中，用 0 表示正数，用 1 表示负数。例如 int 类型的 -10 和 +16 在内存中的表示如下：

![image-20230318145650865](C:\Users\王凯威\AppData\Roaming\Typora\typora-user-images\image-20230318145650865.png)

short、int 和 long 类型默认都是带符号位的，符号位以外的内存才是数值位。如果只考虑正数，那么各种类型能表示的数值范围（取值范围）就比原来小了一半。

但是在很多情况下，我们非常确定某个数字只能是正数，比如班级学生的人数、字符串的长度、内存地址等，这个时候符号位就是多余的了，就不如删掉符号位，把所有的位都用来存储数值，这样能表示的数值范围更大（大一倍）。

C 语言允许我们这样做，如果不希望设置符号位，可以在数据类型前面加上 unsigned 关键字，例如：

~~~C
unsigned short a = 12;
unsigned int b = 1002;
unsigned long c = 9892320;
~~~

这样，short、int、long 中就没有符号位了，所有的位都用来表示数值，正数的取值范围更大了。这也意味着，使用了 unsigned 后只能表示正数，不能再表示负数了。
如果将一个数字分为符号和数值两部分，那么不加 unsigned 的数字称为有符号数，能表示正数和负数，加了unsigned 的数字称为无符号数，只能表示正数。
注意一个小细节，如果是 unsigned int 类型，那么可以省略 int ，只写 unsigned，例如：

~~~c
unsigned n = 100;
~~~

它等价于：

~~~C
unsigned int n = 100;
~~~

无符号数可以以八进制、十进制和十六进制的形式输出，它们对应的格式控制符分别为：

|          | unsigned short | unsigned int | unsigned long |
| -------- | -------------- | ------------ | ------------- |
| 八进制   | %ho            | %o           | %lo           |
| 十进制   | %hu            | %u           | %lu           |
| 十六进制 | %hx或%hX       | %x或%X       | %lx或%lX      |

下面的代码进行了全面的演示：

~~~c
#include <stdio.h>
int main()
{
short a = 0100; //八进制
int b = -0x1; //十六进制
long c = 720; //十进制
unsigned short m = 0xffff; //十六进制
unsigned int n = 0x80000000; //十六进制
unsigned long p = 100; //十进制
//以无符号的形式输出有符号数
printf("a=%#ho, b=%#x, c=%ld\n", a, b, c);
//以有符号数的形式输出无符号类型（只能以十进制形式输出）
printf("m=%hd, n=%d, p=%ld\n", m, n, p);
return 0;
}
~~~

运行结果：

```
a=0100, b=0xffffffff, c=720
m=-1, n=-2147483648, p=100
```

### 1.6浮点数类型（float,double）

小数分为整数部分和小数部分，它们由点号.分隔，例如 0.0、75.0、4.023、0.27、-937.198 -0.27 等都是合法的小数，这是最常见的小数形式，我们将它称为十进制形式。

此外，小数也可以采用指数形式，例如7.25×10^2、0.0368×10^5、100.22×10^-2、-27.36×10^-3 等。

任何小数都可以用指数形式来表示。



C 语言同时支持以上两种形式的小数。但是在书写时，C 语言中的指数形式和数学中的指数形式有所差异。
C 语言中小数的指数形式为：

~~~
aEn 或 aen
~~~

a 为尾数部分，是一个十进制数；n 为指数部分，是一个十进制整数；E 或 e 是固定的字符，用于分割尾数部分和指数部分。整个表达式等价于 a×10^n。



指数形式的小数举例：

2.1E5 = 2.1×10^5，其中 2.1 是尾数，5 是指数。
3.7E-2 = 3.7×10^-2，其中 3.7 是尾数，-2 是指数。
0.5E7 = 0.5×10^7，其中 0.5 是尾数，7 是指数。

C 语言中常用的小数有两种类型，分别是 float 或 double；float 称为单精度浮点型，double 称为双精度浮点型。
不像整数，小数没有那么多幺蛾子，小数的长度是固定的，float 始终占用 4 个字节，double 始终占用 8 个字节。

##### 小数的输出

`%f` 以十进制形式输出 float 类型；
`%lf` 以十进制形式输出 double 类型；
`%e` 以指数形式输出 float 类型，输出结果中的 e 小写；
`%E` 以指数形式输出 float 类型，输出结果中的 E 大写；
`%le` 以指数形式输出 double 类型，输出结果中的 e 小写；
`%lE` 以指数形式输出 double 类型，输出结果中的 E 大写。

下面的代码演示了小数的表示以及输出：

~~~C
#include <stdio.h>
#include <stdlib.h>
int main()
{
float a = 0.302;
float b = 128.101;
double c = 123;
float d = 112.64E3;
double e = 0.7623e-2;
float f = 1.23002398;
printf("a=%e \nb=%f \nc=%lf \nd=%lE \ne=%lf \nf=%f\n", a, b, c, d, e, f);
return 0;
}
~~~

运行结果：

```
a=3.020000e-01
b=128.100998
c=123.000000
d=1.126400E+05
e=0.007623
f=1.230024
```

对代码的说明：
1) %f 和 %lf 默认保留六位小数，不足六位以 0 补齐，超过六位按四舍五入截断。
2) 将整数赋值给 float 变量时会变成小数。
3) 以指数形式输出小数时，输出结果为科学计数法；也就是说，尾数部分的取值为：0 ≤ 尾数 < 10。
4) b 的输出结果让人费解，才三位小数，为什么不能精确输出，而是输出一个近似值呢？这和小数在内存中的存储
形式有关，很多简单的小数压根不能精确存储，所以也就不能精确输出



另外，小数还有一种更加智能的输出方式，就是使用%g。%g 会对比小数的十进制形式和指数形式，以最短的方式
来输出小数，让输出结果更加简练。所谓最短，就是输出结果占用最少的字符。

%g 使用示例：

~~~C
#include <stdio.h>
#include <stdlib.h>
int main()
{
float a = 0.00001;
float b = 30000000;
float c = 12.84;
float d = 1.229338455;
printf("a=%g \nb=%g \nc=%g \nd=%g\n", a, b, c, d);
return 0;
}
~~~

运行结果：

```
a=1e-05
b=3e+07
c=12.84
d=1.22934
```

对各个小数的分析：

1. a 的十进制形式是 0.00001，占用七个字符的位置，a 的指数形式是 1e-05，占用五个字符的位置，指数形式较短，所以以指数的形式输出。
2. b 的十进制形式是 30000000，占用八个字符的位置，b 的指数形式是 3e+07，占用五个字符的位置，指数形式较短，所以以指数的形式输出。
3. c 的十进制形式是 12.84，占用五个字符的位置，c 的指数形式是 1.284e+01，占用九个字符的位置，十进制形式较短，所以以十进制的形式输出。
4. d 的十进制形式是 1.22934，占用七个字符的位置，d 的指数形式是 1.22934e+00，占用十一个字符的位置，十进制形式较短，所以以十进制的形式输出。

##### 数字的后缀
一个数字，是有默认类型的：对于整数，默认是 int 类型；对于小数，默认是 double 类型。
请看下面的例子：

~~~c
long a = 100;
int b = 294;
float x = 52.55;
double y = 18.6;
~~~

100 和 294 这两个数字默认都是 int 类型的，将 100 赋值给 a，必须先从 int 类型转换为 long 类型，而将 294
赋值给 b 就不用转换了。
52.55 和 18.6 这两个数字默认都是 double 类型的，将 52.55 赋值给 x，必须先从 double 类型转换为 float 类
型，而将 18.6 赋值给 y 就不用转换了。

如果不想让数字使用默认的类型，那么可以给数字加上后缀，手动指明类型：
在整数后面紧跟 l 或者 L（不区分大小写）表明该数字是 long 类型；
在小数后面紧跟 f 或者 F（不区分大小写）表明该数字是 float 类型。

请看下面的代码：

~~~C
long a = 100l;
int b = 294;
short c = 32L;
float x = 52.55f;
double y = 18.6F;
float z = 0.02;
~~~

加上后缀，虽然数字的类型变了，但这并不意味着该数字只能赋值给指定的类型，它仍然能够赋值给其他的类型，
只要进行了一下类型转换就可以了。

##### 小数和整数相互赋值

在 C 语言中，整数和小数之间可以相互赋值：

- 将一个整数赋值给小数类型，在小数点后面加 0 就可以，加几个都无所谓。
- 将一个小数赋值给整数类型，就得把小数部分丢掉，只能取整数部分，这会改变数字本来的值。注意是直接丢掉小数部分，而不是按照四舍五入取近似值

请看下面的代码：

~~~c
#include <stdio.h>
int main() 
{
float f = 251;
int w = 19.427;
int x = 92.78;
int y = 0.52;
int z = -87.27;
printf("f = %f, w = %d, x = %d, y = %d, z = %d\n", f, w, x, y, z);
return 0;
}
~~~

运行结果：

```
f = 251.000000, w = 19, x = 92, y = 0, z = -87
```

### 1.7在 C 语言中使用英文字符

#### 字符的表示

字符类型由单引号' '包围，字符串由双引号" "包围。

下面的例子演示了如何给 char 类型的变量赋值：

~~~c
//正确的写法
char a = '1';
char b = '$';
char c = 'X';
char d = ' '; // 空格也是一个字符
//错误的写法
char x = '中'; //char 类型不能包含 ASCII 编码之外的字符
char y = 'Ａ'; //A 是一个全角字符
char z = "t"; //字符类型应该由单引号包围
~~~

#### 字符的输出

输出 char 类型的字符有两种方法，分别是：
使用专门的字符输出函数 putchar；
使用通用的格式化输出函数 printf，char 对应的格式控制符是%c。

请看下面的演示：

~~~c
#include <stdio.h>
int main() {
char a = '1';
char b = '$';
char c = 'X';
char d = ' ';
//使用 putchar 输出
putchar(a); putchar(d);
putchar(b); putchar(d);
putchar(c); putchar('\n');
//使用 printf 输出
printf("%c %c %c\n", a, b, c);
return 0;
}
~~~

运行结果：

```
1 $ X
1 $ X
```

putchar 函数每次只能输出一个字符，输出多个字符需要调用多次。

#### 字符与整数

我们知道，计算机在存储字符时并不是真的要存储字符实体，而是存储该字符在字符集中的编号（也可以叫编码值）。
对于 char 类型来说，它实际上存储的就是字符的 ASCII 码。
无论在哪个字符集中，字符编号都是一个整数；从这个角度考虑，字符类型和整数类型本质上没有什么区别。
我们可以给字符类型赋值一个整数，或者以整数的形式输出字符类型。反过来，也可以给整数类型赋值一个字符，
或者以字符的形式输出整数类型。
请看下面的例子：

~~~c
#include <stdio.h>
int main()
{
char a = 'E';
char b = 70;
int c = 71;
int d = 'H';
printf("a: %c, %d\n", a, a);
printf("b: %c, %d\n", b, b);
printf("c: %c, %d\n", c, c);
printf("d: %c, %d\n", d, d);
return 0;
}
~~~

输出结果：

```
a: E, 69
b: F, 70
c: G, 71
d: H, 72
```

可以说，是 ASCII 码表将英文字符和整数关联了起来。

## 二、运算符

###  2.1、C 语言加减乘除运算

加减乘除是常见的数学运算，C 语言当然支持，不过，C 语言中的运算符号与数学中的略有不同，请见下表。

|       | 加法 | 减法 | 乘法 | 除法 | 取余 |
| ----- | ---- | ---- | ---- | ---- | ---- |
| 数学  | +    | -    | ×    | ÷    | 无   |
| c语言 | +    | -    | *    | /    | %    |

下面的代码演示了如何在 C 语言中进行加减乘除运算：

~~~c
#include <stdio.h>
int main()
{
int a = 12;
int b = 100;.
float c = 8.5;
int m = a + b;
float n = b * c;
double p = a / c;
int q = b % a;
printf("m=%d, n=%f, p=%lf, q=%d\n", m, n, p, q);
return 0;
}
~~~

输出结果：

```
m=112, n=850.000000, p=1.411765, q=4
```

也可以让数字直接参与运算：

~~~c
#include <stdio.h>
int main()
{
int a = 12;
int b = 100;
float c = 8.9;
int m = a - b; // 变量参与运算
int n = a + 239; // 有变量也有数字
double p = 12.7 * 34.3; // 数字直接参与运算
printf("m=%d, n=%d, p=%lf\n", m, n, p);
printf("m*2=%d, 6/3=%d, m*n=%ld\n", m * 2, 6 / 3, m*n);
return 0;
}
~~~

输出结果：

```
m=-88, n=251, p=435.610000
m*2=-176, 6/3=2, m*n=-22088
```

#### 对除法的说明

C 语言中的除法运算有点奇怪，不同类型的除数和被除数会导致不同类型的运算结果：

- 当除数和被除数都是整数时，运算结果也是整数；如果不能整除，那么就直接丢掉小数部分，只保留整数部分，这跟将小数赋值给整数类型是一个道理。
- 一旦除数和被除数中有一个是小数，那么运算结果也是小数，并且是 double 类型的小数。

请看下面的代码：

~~~c
#include <stdio.h>
int main()
{
int a = 100;
int b = 12;
float c = 12.0;
double p = a / b;
double q = a / c;
printf("p=%lf, q=%lf\n", p, q);
return 0;
}
~~~

运行结果：

```
p=8.000000, q=8.333333
```

a 和 b 都是整数，a / b 的结果也是整数，所以赋值给 p 变量的也是一个整数，这个整数就是 8。
另外需要注意的一点是除数不能为 0，因为任何一个数字除以 0 都没有意义。

#### 对取余运算的说明

取余，也就是求余数，使用的运算符是 %。C 语言中的取余运算只能针对整数，也就是说，% 的两边都必须是整数，
不能出现小数，否则编译器会报错。
另外，余数可以是正数也可以是负数，由 % 左边的整数决定：

- 如果 % 左边是正数，那么余数也是正数；
- 如果 % 左边是负数，那么余数也是负数。

请看下面的例子：

~~~c
#include <stdio.h>
int main()
{
printf(
"100%%12=%d \n100%%-12=%d \n-100%%12=%d \n-100%%-12=%d \n",
100 % 12, 100 % -12, -100 % 12, -100 % -12);
return 0;
}
~~~

运行结果：

```
100%12=4
100%-12=4
-100%12=-4
-100%-12=-4
```

在 printf 中，% 是格式控制符的开头，是一个特殊的字符，不能直接输出；要想输出 %，必须在它的前面再加一个 %，
这个时候 % 就变成了普通的字符，而不是用来表示格式控制符了。

#### 加减乘除运算的简写

有时候我们希望对一个变量进行某种运算，然后再把运算结果赋值给变量本身，请看下面的例子：

~~~c
#include <stdio.h>
int main()
{
int a = 12;
int b = 10;
printf("a=%d\n", a);
a = a + 8;
printf("a=%d\n", a);
a = a * b;
printf("a=%d\n", a);
return 0;
}
~~~

输出结果：

```
a=12
a=20
a=200
```

在 C 语言中，对变量本身进行运算可以有简写形式。假设用 # 来表示某种运算符，那么

```
a = a # b
```

可以简写为：

```
a #= b
```

#表示 +、-、*、/、% 中的任何一种运算符。

上例中 a = a + 8 可以简写为 a += 8，a = a * b 可以简写为 a *= b。

###  2.2C 语言自增(++)和自减(--)运算符

一个整数类型的变量自身加 1 可以这样写：

```c
a = a + 1;
```

或者

```C
a += 1;
```

不过，C 语言还支持另外一种更加简洁的写法，就是：

```C
a++;
```

或者

```C
++a;
```

这种写法叫做自加或自增，意思很明确，就是每次自身加 1。相应的，也有 `a--`和`--a`,它们叫做自减，表示自身减 1。
++和--分别称为自增运算符和自减运算符，它们在循环结构中使用很频繁。

自增和自减的示例：

~~~c
#include <stdio.h>
int main()
{
int a = 10, b = 20;
printf("a=%d, b=%d\n", a, b);
++a;
--b;
printf("a=%d, b=%d\n", a, b);
a++;
b--;
printf("a=%d, b=%d\n", a, b);
return 0;
}
~~~

运行结果：

```
a=10, b=20
a=11, b=19
a=12, b=18
```

自增自减完成后，会用新值替换旧值，将新值保存在当前变量中。
自增自减的结果必须得有变量来接收，所以自增自减只能针对变量，不能针对数字，例如 10++就是错误的。

需要重点说明的是，++ 在变量前面和后面是有区别的：

- ++ 在前面叫做前自增（例如 ++a）。前自增先进行自增运算，再进行其他操作。
- ++ 在后面叫做后自增（例如 a++）。后自增先进行其他操作，再进行自增运算。

下面的例子能更好地说明前自增（前自减）和后自增（后自减）的区别：

~~~c
#include <stdio.h>
int main()
{
int a = 10, b = 20, c = 30, d = 40;
int a1 = ++a, b1 = b++, c1 = --c, d1 = d--;
printf("a=%d, a1=%d\n", a, a1);
printf("b=%d, b1=%d\n", b, b1);
printf("c=%d, c1=%d\n", c, c1);
printf("d=%d, d1=%d\n", d, d1);
return 0;
}
~~~

输出结果：

```
`a=11, a1=11
`b=21, b1=20
`c=29, c1=29
`d=39, d1=40
```

a、b、c、d 的输出结果相信没有疑问，下面重点分析 a1、b1、c1、d1：
1) 对于 a1=++a，先执行 ++a，结果为 11，再将 11 赋值给 a1，所以 a1 的最终值为 11。而 a 经过自增，最终的值也为 11。
2) 对于 b1=b++，b 的值并不会立马加 1，而是先把 b 原来的值交给 b1，然后再加 1。b 原来的值为 20，所以b1 的值也就为 20。而 b 经过自增，最终值为 21。
3) 对于 c1=--c，先执行 --c，结果为 29，再将 29 赋值给 c1，所以 c1 的最终值为 29。而 c 经过自减，最终的值也为 29。
4) 对于 d1=d--，d 的值并不会立马减 1，而是先把 d 原来的值交给 d1，然后再减 1。d 原来的值为 40，所以d1 的值也就为 40。而 d 经过自减，最终值为 39。
5) 可以看出：a1=++a;会先进行自增操作，再进行赋值操作；而 b1=b++;会先进行赋值操作，再进行自增操作。c1=--c;和 d1=d--;也是如此。

为了强化记忆，我们再来看一个自增自减的综合示例：

~~~c
#include <stdio.h>
int main()
{
int a = 12, b = 1;
int c = a - (b--); // ①
int d = (++a) - (--b); // ②
printf("c=%d, d=%d\n", c, d);
return 0
}
~~~

输出结果：

```
c=11, d=14
```

我们来分析一下：

1) 执行语句①时，因为是后自减，会先进行 a-b 运算，结果是 11，然后 b 再自减，就变成了 0；最后再将 a-b 的结果（也就是 11）交给 c，所以 c 的值是 11。
2) 执行语句②之前，b 的值已经变成 0。对于 d=(++a)-(--b)，a 会先自增，变成 13，然后 b 再自减，变成 -1，最后再计算 13-(-1)，结果是 14，交给 d，所以 d 最终是 14。

### 2.3C 语言运算符的优先级和结合性

请看下面的代码：

~~~c
#include <stdio.h>
int main() {
int a = 16, b = 4, c = 2;
int d = a + b * c;
int e = a / b * c;
printf("d=%d, e=%d\n", d, e);
return 0;
}
~~~

运行结果：

```
d=24, e=8
```

对于表达式 a + b * c，如果按照数学规则推导，应该先计算乘法，再计算加法；b * c 的结果为 8，a + 8 的结果为 24，所以 d 最终的值也是 24。从运行结果可以看出，我们的推论得到了证实，C 语言也是先计算乘法再计算加法，和数学中的规则一样。
先计算乘法后计算加法，说明乘法运算符的优先级比加法运算符的优先级高。所谓优先级，就是当多个运算符出现在同一个表达式中时，先执行哪个运算符。

一下子记住所有运算符的优先级并不容易，还好 C 语言中大部分运算符的优先级和数学中是一样的，在以后的编程过程中也会逐渐熟悉起来。如果实在搞不清，可以加括号，就像下面这样：

~~~c
int d = a + (b * c);
~~~

括号的优先级是最高的，括号中的表达式会优先执行，这样各个运算符的执行顺序就一目了然了。



 对于表达式 a / b * c，除法和乘法的优先级是相同的，这个时候到底该先执行哪一个呢？
按照数学规则应该从左到右，先计算除法，在计算乘法；a / b 的结果是 4，4 * c 的结果是 8，所以 e 最终的值也是 8。这个推论也从运行结果中得到了证实，C 语言的规则和数学的规则是一样的。当乘法和除法的优先级相同时，编译器很明显知道先执行除法，再执行乘法，这是根据运算符的结合性来判定的。所谓结合性，就是当一个表达式中出现多个优先级相同的运算符时，先执行哪个运算符：先执行左边的叫左结合性，先执行右边的叫右结合性。
/和*的优先级相同，又都具有左结合性，所以先执行左边的除法，再执行右边的乘法。



像 +、-、*、/ 这样的运算符，它的两边都有要计算的数据，每份这样的数据都称作一个操作数，一个运算符需要 n 个操作数就称为 n 目运算符。例如：

- +、-、、/、= 是双目运算符；
- ++、-- 是单目运算符；
- ? : 是三目运算符

### 2.4C 语言数据类型转换（自动转换+强制转换）

#### 自动类型转换

自动类型转换就是编译器默默地、隐式地、偷偷地进行的数据类型转换，这种转换不需要程序员干预，会自动发生。

1. 将一种类型的数据赋值给另外一种类型的变量时就会发生自动类型转换，例如：

   ```
   float f = 100;
   ```

   100 是 int 类型的数据，需要先转换为 float 类型才能赋值给变量 f。再如：

   ```
   int n = f;
   ```

   f 是 float 类型的数据，需要先转换为 int 类型才能赋值给变量 n。
   在赋值运算中，赋值号两边的数据类型不同时，需要把右边表达式的类型转换为左边变量的类型，这可能会导致数据失真，或者精度降低；所以说，自动类型转换并不一定是安全的。对于不安全的类型转换，编译器一般会给出警告。

2) 在不同类型的混合运算中，编译器也会自动地转换数据类型，将参与运算的所有数据先转换为同一种类型，然后再进行计算。转换的规则如下：
转换按数据长度增加的方向进行，以保证数值不失真，或者精度不降低。例如，int 和 long 参与运算时，先把int 类型的数据转成 long 类型后再进行运算。
所有的浮点运算都是以双精度进行的，即使运算中只有 float 类型，也要先转换为 double 类型，才能进行运算。
char 和 short 参与运算时，必须先转换成 int 类型。
下图对这种转换规则进行了更加形象地描述：

![image-20230318160809951](C:\Users\王凯威\AppData\Roaming\Typora\typora-user-images\image-20230318160809951.png)

自动类型转换示例：

~~~c
#include<stdio.h>
int main() {
float PI = 3.14159;
int s1, r = 5;
double s2;
s1 = r * r * PI;
s2 = r * r * PI;
printf("s1=%d, s2=%f\n", s1, s2);
return 0;
}
~~~

运行结果：

```
s1=78, s2=78.539749
```

在计算表达式 r*r*PI 时，r 和 PI 都被转换成 double 类型，表达式的结果也是 double 类型。但由于 s1 为整型，
所以赋值运算的结果仍为整型，舍去了小数部分，导致数据失真。

#### 强制类型转换

自动类型转换是编译器根据代码的上下文环境自行判断的结果，有时候并不是那么“智能”，不能满足所有的需求。如果需要，程序员也可以自己在代码中明确地提出要进行类型转换，这称为强制类型转换。
自动类型转换是编译器默默地、隐式地进行的一种类型转换，不需要在代码中体现出来；强制类型转换是程序员明确提出的、需要通过特定格式的代码来指明的一种类型转换。换句话说，自动类型转换不需要程序员干预，强制类型转换必须有程序员干预。

强制类型转换的格式为：

```
(type_name) expression
```

`type_name` 为新类型名称，`expression` 为表达式。例如：

~~~c
(float)a; //将变量 a 转换为 float 类型
(int)(x + y); //把表达式 x+y 的结果转换为 int 整型
(float)100; //将数值 100（默认为int类型）转换为 float 类型
~~~

下面是一个需要强制类型转换的经典例子：

~~~c
#include <stdio.h>
int main() {
int sum = 103; //总数
int count = 7; //数目
double average; //平均数
average = (double)sum / count;
printf("Average is %lf!\n", average);
return 0;
}
~~~

运行结果：

```
Average is 14.714286!
```

sum 和 count 都是 int 类型，如果不进行干预，那么 sum / count 的运算结果也是 int 类型，小数部分将被丢弃；虽然是 average 是 double 类型，可以接收小数部分，但是心有余力不足，小数部分提前就被“阉割”了，它只能接收到整数部分，这就导致除法运算的结果严重失真。
既然 average 是 double 类型，为何不充分利用，尽量提高运算结果的精度呢？为了达到这个目标，我们只要将sum 或者 count 其中之一转换为 double 类型即可。上面的代码中，我们将 sum 强制转换为 double 类型，这样sum / count 的结果也将变成 double 类型，就可以保留小数部分了，average 接收到的值也会更加精确。

在这段代码中，有两点需要注意：

1. 对于除法运算，如果除数和被除数都是整数，那么运算结果也是整数，小数部分将被直接丢弃；如果除数和被除数其中有一个是小数，那么运算结果也是小数。
2. ( )的优先级高于/，对于表达式(double) sum / count，会先执行(double) sum，将 sum 转换为 double 类型，然后再进行除法运算，这样运算结果也是 double 类型，能够保留小数部分。注意不要写作(double) (sum /count)，这样写运算结果将是 3.000000，仍然不能保留小数部分。

#### 类型转换只是临时性的

无论是自动类型转换还是强制类型转换，都只是为了本次运算而进行的临时性转换，转换的结果也会保存到临时的内存空间，不会改变数据本来的类型或者值。请看下面的例子：

~~~c
#include <stdio.h>
int main() 
{
double total = 400.8; //总价
int count = 5; //数目
double unit; //单价
int total_int = (int)total;
unit = total / count;
printf("total=%lf, total_int=%d, unit=%lf\n", total, total_int, unit);
return 0;
}
~~~

运行结果：

```
total=400.800000, total_int=400, unit=80.160000
```

注意看第 6 行代码，total 变量被转换成了 int 类型才赋值给 total_int 变量，而这种转换并未影响 total 变量本身的类型和值。如果 total 的值变了，那么 total 的输出结果将变为 400.000000；如果 total 的类型变了，那么 unit的输出结果将变为 80.000000。

#### 自动类型转换 VS 强制类型转换
在 C 语言中，有些类型既可以自动转换，也可以强制转换，例如 int 到 double，float 到 int 等；而有些类型只能强制转换，不能自动转换，例如以后将要学到的 void * 到 int *，int 到 char * 等。
可以自动转换的类型一定能够强制转换，但是，需要强制转换的类型不一定能够自动转换。现在我们学到的数据类型，既可以自动转换，又可以强制转换，以后我们还会学到一些只能强制转换而不能自动转换的类型。可以自动进行的类型转换一般风险较低，不会对程序带来严重的后果，例如，int 到 double 没有什么缺点，float到 int 顶多是数值失真。只能强制进行的类型转换一般风险较高，或者行为匪夷所思，例如，char * 到 int * 就是很奇怪的一种转换，这会导致取得的值也很奇怪，再如，int 到 char * 就是风险极高的一种转换，一般会导致程序崩溃。
使用强制类型转换时，自己要意识到潜在的风险。